// Code generated by MockGen. DO NOT EDIT.
// Source: ops.go
//
// Generated by this command:
//
//	mockgen -source=ops.go -package=ops -destination=mock_ops.go
//
// Package ops is a generated GoMock package.
package ops

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockOps is a mock of Ops interface.
type MockOps struct {
	ctrl     *gomock.Controller
	recorder *MockOpsMockRecorder
}

// MockOpsMockRecorder is the mock recorder for MockOps.
type MockOpsMockRecorder struct {
	mock *MockOps
}

// NewMockOps creates a new mock instance.
func NewMockOps(ctrl *gomock.Controller) *MockOps {
	mock := &MockOps{ctrl: ctrl}
	mock.recorder = &MockOpsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOps) EXPECT() *MockOpsMockRecorder {
	return m.recorder
}

// ExtractTarWithSELinux mocks base method.
func (m *MockOps) ExtractTarWithSELinux(srcPath, destPath string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExtractTarWithSELinux", srcPath, destPath)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExtractTarWithSELinux indicates an expected call of ExtractTarWithSELinux.
func (mr *MockOpsMockRecorder) ExtractTarWithSELinux(srcPath, destPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtractTarWithSELinux", reflect.TypeOf((*MockOps)(nil).ExtractTarWithSELinux), srcPath, destPath)
}

// ForceExpireSeedCrypto mocks base method.
func (m *MockOps) ForceExpireSeedCrypto(recertContainerImage, authFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ForceExpireSeedCrypto", recertContainerImage, authFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// ForceExpireSeedCrypto indicates an expected call of ForceExpireSeedCrypto.
func (mr *MockOpsMockRecorder) ForceExpireSeedCrypto(recertContainerImage, authFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForceExpireSeedCrypto", reflect.TypeOf((*MockOps)(nil).ForceExpireSeedCrypto), recertContainerImage, authFile)
}

// ImageExists mocks base method.
func (m *MockOps) ImageExists(img string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ImageExists", img)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ImageExists indicates an expected call of ImageExists.
func (mr *MockOpsMockRecorder) ImageExists(img any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImageExists", reflect.TypeOf((*MockOps)(nil).ImageExists), img)
}

// IsImageMounted mocks base method.
func (m *MockOps) IsImageMounted(img string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsImageMounted", img)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsImageMounted indicates an expected call of IsImageMounted.
func (mr *MockOpsMockRecorder) IsImageMounted(img any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsImageMounted", reflect.TypeOf((*MockOps)(nil).IsImageMounted), img)
}

// RecertFullFlow mocks base method.
func (m *MockOps) RecertFullFlow(recertContainerImage, authFile, configFile string, preRecertOperations, postRecertOperations func() error, additionalPodmanParams ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{recertContainerImage, authFile, configFile, preRecertOperations, postRecertOperations}
	for _, a := range additionalPodmanParams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RecertFullFlow", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RecertFullFlow indicates an expected call of RecertFullFlow.
func (mr *MockOpsMockRecorder) RecertFullFlow(recertContainerImage, authFile, configFile, preRecertOperations, postRecertOperations any, additionalPodmanParams ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{recertContainerImage, authFile, configFile, preRecertOperations, postRecertOperations}, additionalPodmanParams...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecertFullFlow", reflect.TypeOf((*MockOps)(nil).RecertFullFlow), varargs...)
}

// RemountSysroot mocks base method.
func (m *MockOps) RemountSysroot() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemountSysroot")
	ret0, _ := ret[0].(error)
	return ret0
}

// RemountSysroot indicates an expected call of RemountSysroot.
func (mr *MockOpsMockRecorder) RemountSysroot() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemountSysroot", reflect.TypeOf((*MockOps)(nil).RemountSysroot))
}

// RestoreOriginalSeedCrypto mocks base method.
func (m *MockOps) RestoreOriginalSeedCrypto(recertContainerImage, authFile string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestoreOriginalSeedCrypto", recertContainerImage, authFile)
	ret0, _ := ret[0].(error)
	return ret0
}

// RestoreOriginalSeedCrypto indicates an expected call of RestoreOriginalSeedCrypto.
func (mr *MockOpsMockRecorder) RestoreOriginalSeedCrypto(recertContainerImage, authFile any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreOriginalSeedCrypto", reflect.TypeOf((*MockOps)(nil).RestoreOriginalSeedCrypto), recertContainerImage, authFile)
}

// RunBashInHostNamespace mocks base method.
func (m *MockOps) RunBashInHostNamespace(command string, args ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{command}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunBashInHostNamespace", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunBashInHostNamespace indicates an expected call of RunBashInHostNamespace.
func (mr *MockOpsMockRecorder) RunBashInHostNamespace(command any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{command}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunBashInHostNamespace", reflect.TypeOf((*MockOps)(nil).RunBashInHostNamespace), varargs...)
}

// RunInHostNamespace mocks base method.
func (m *MockOps) RunInHostNamespace(command string, args ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{command}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunInHostNamespace", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunInHostNamespace indicates an expected call of RunInHostNamespace.
func (mr *MockOpsMockRecorder) RunInHostNamespace(command any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{command}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunInHostNamespace", reflect.TypeOf((*MockOps)(nil).RunInHostNamespace), varargs...)
}

// RunRecert mocks base method.
func (m *MockOps) RunRecert(recertContainerImage, authFile, recertConfigFile string, additionalPodmanParams ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{recertContainerImage, authFile, recertConfigFile}
	for _, a := range additionalPodmanParams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunRecert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunRecert indicates an expected call of RunRecert.
func (mr *MockOpsMockRecorder) RunRecert(recertContainerImage, authFile, recertConfigFile any, additionalPodmanParams ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{recertContainerImage, authFile, recertConfigFile}, additionalPodmanParams...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunRecert", reflect.TypeOf((*MockOps)(nil).RunRecert), varargs...)
}

// RunUnauthenticatedEtcdServer mocks base method.
func (m *MockOps) RunUnauthenticatedEtcdServer(authFile, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunUnauthenticatedEtcdServer", authFile, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunUnauthenticatedEtcdServer indicates an expected call of RunUnauthenticatedEtcdServer.
func (mr *MockOpsMockRecorder) RunUnauthenticatedEtcdServer(authFile, name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunUnauthenticatedEtcdServer", reflect.TypeOf((*MockOps)(nil).RunUnauthenticatedEtcdServer), authFile, name)
}

// SystemctlAction mocks base method.
func (m *MockOps) SystemctlAction(action string, args ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []any{action}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SystemctlAction", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SystemctlAction indicates an expected call of SystemctlAction.
func (mr *MockOpsMockRecorder) SystemctlAction(action any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{action}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SystemctlAction", reflect.TypeOf((*MockOps)(nil).SystemctlAction), varargs...)
}

// UnmountAndRemoveImage mocks base method.
func (m *MockOps) UnmountAndRemoveImage(img string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnmountAndRemoveImage", img)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnmountAndRemoveImage indicates an expected call of UnmountAndRemoveImage.
func (mr *MockOpsMockRecorder) UnmountAndRemoveImage(img any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnmountAndRemoveImage", reflect.TypeOf((*MockOps)(nil).UnmountAndRemoveImage), img)
}

// waitForEtcd mocks base method.
func (m *MockOps) waitForEtcd(healthzEndpoint string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "waitForEtcd", healthzEndpoint)
	ret0, _ := ret[0].(error)
	return ret0
}

// waitForEtcd indicates an expected call of waitForEtcd.
func (mr *MockOpsMockRecorder) waitForEtcd(healthzEndpoint any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "waitForEtcd", reflect.TypeOf((*MockOps)(nil).waitForEtcd), healthzEndpoint)
}
